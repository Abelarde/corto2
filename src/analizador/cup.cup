package analizador;
import java_cup.runtime.*;
import java.util.*;
import java.io.*;


parser code
{:
public static String error;
public static String error_lexico;
//public static List<String> crear_usuarios =  new ArrayList<String>();
           

//metodo al que se llama automaticamente ante algun error sintactico
public void syntax_error(Symbol s){

error = "Error en la Linea " + (s.right) +" Columna "+ s.left + ". Identificador "
+s.value +" " + s.sym + " no reconocido.";

error_lexico = " Identificador " +s.value + " no reconocido.";

System.out.println("Error en la Linea " + s.right +" Columna "+ s.left + ". Identificador "
+s.value +" " + s.sym + " no reconocido." );
//UIBuilder.mListaErroresSin.add(new ErroresLexicos(1, "" + s.value, s.right, s.left));
}

//metodo al que llama cuando ya no es posible recuperarse de errores
public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{

error = "Error en la linea " + (s.right)+ " Columna "+ s.left +". Identificador " + 
s.value + " no reconocido.";

System.out.println("uError en la linea " + s.right+ " Columna "+ s.left +". Identificador" + 
s.value + " no reconocido.");
}

:}

action code
{:
    //public  Usuarios usu_comodin = new Usuarios();
    //public  Hashtable<Integer, Usuarios> lst_usuarios = new Hashtable<Integer, Usuarios>();

:} 

//REVISAR POSIBLE CASTEO 
terminal  re_request, re_reply, re_InicioUsuario, re_CrearUsuario, re_id, re_password, re_nombre, re_apellido, re_telefono, re_email, re_direccion, re_Usuario, re_access;

non terminal PRINCIPAL, CODIGO, LINEA, PETICION, USUARIO, INICIO, CREAR, TIENDA, DOS, LSDOS, SIGUE, JA, CRUD, CREAR_T, PRODUCTO, DOS_PRO, JO, LSPRO, SIGUE_PRO, JU, CREAR_P, EE, CRUD_SER, PET_DOS, JAT, SERVIDOR, INICIO_SER, LOG, VALORES_LOG, TIENDA_SER;

precedence left sig_mas, sig_guion, sig_or;
precedence left sig_por, sig_div, sig_and;
precedence nonassoc sig_igualigual;
//precedence nonassoc  sig_dolar;



S ::= E {: System.out.println("Sentencencia analizada correctamente. Sin errores");
           System.out.println(E.C3D); 
        :};

E ::= E mas T { E.TMP = new_temp(); E.C3D = E1.C3D + T.C3D + E.TMP + “=” + E1.TMP “+” + T.TMP;}
    | E menos T { E.TMP = new_temp();  E.C3D = E1.C3D + T.C3D + E.TMP + “=” + E1.TMP “-” + T.TMP;}
    |T { E.TMP = T.TMP; E.C3D = T.C3D; };

T ::= T por F {T.TMP = new_temp(); T.C3D = T1.C3D + F.C3D + T.TMP + “=” + T1.TMP “*” + F.TMP;}
    | T div F {T.TMP = new_temp(); T.C3D = T1.C3D + F.C3D + T.TMP + “=” + T1.TMP “/” + F.TMP;}
    |F {T.TMP = F.TMP; T.C3D = F.C3D;};

F ::= left_par E right_par {F.TMP = E.TMP; F.C3D = E.C3D;}
    |id {F.TMP = id.lex_value; F.C3D = "";}
    |digito; {F.TMP = digito.lex_value; F.C3D = "";}






EE ::= sig_abre_llave AA:a sig_cierra_llave {: RESULT = a.toString() ; System.out.println(a.toString() + "CALCULOOSSSS");:}
	|AA:a {: RESULT = a.toString() ;  System.out.println(a.toString() + "CALCULOOSSSS"); :};

AA ::= AA:a sig_mas AA:b {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 + val2; RESULT = String.valueOf(re);:}
	|AA:a sig_guion AA:b {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 - val2; RESULT = String.valueOf(re);:}
	|AA:a sig_por AA:b {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 * val2; RESULT = String.valueOf(re);:}
	|AA:a sig_div AA:b {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 / val2; RESULT = String.valueOf(re);:}
	|re_Rq sig_abre_parentesis AA:a sig_cierra_parentesis {: float val1 = Float.parseFloat((String)a) ;float re = (float)Math.sqrt(val1);  int val2 = Math.round(re); RESULT = String.valueOf(val2); :}
	|re_Ptn sig_abre_parentesis AA:a sig_cierra_parentesis  {:int val1 = Integer.parseInt((String)a); int re = (int)Math.pow(val1,2); RESULT = String.valueOf(re);:}
	|sig_abre_parentesis AA:a sig_cierra_parentesis {: RESULT = a.toString() ; :}
	|enteros:a {: RESULT = a.toString() ; :};  //*********************************************************************decimal


TABLA ::= re_Usuario:a {: RESULT =  a.toString() ; :}
		|re_tienda:a {: RESULT = a.toString() ; :}
		|re_producto:a {: RESULT =  a.toString() ; :};

EL ::= EL:a sig_or EL:b {:String val1 = a.toString();	
						  String val2 = b.toString(); 

						  //if(){

						  //}







						  //RESULT = String.valueOf(re);

						:}
	|EL:a sig_and EL:b
	|sig_N sig_abre_parentesis EL:a sig_cierra_parentesis 
	|EL:a sig_igualigual EL:b
	|EL:a sig_mas EL:b  {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 + val2; RESULT = String.valueOf(re);:}
	|EL:a sig_guion EL:b {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 - val2; RESULT = String.valueOf(re);:} 
	|EL:a sig_por EL:b {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 * val2; RESULT = String.valueOf(re);:}
	|EL:a sig_div EL:b {:int val1 = Integer.parseInt((String)a);	int val2 = Integer.parseInt((String)b); int re = val1 / val2; RESULT = String.valueOf(re);:}
	|re_Rq sig_abre_parentesis EL:a sig_cierra_parentesis {:RESULT = a.toString();:}
	|re_Ptn sig_abre_parentesis EL:a sig_cierra_parentesis {:RESULT = a.toString();:}
	|sig_abre_parentesis EL:a sig_cierra_parentesis {:RESULT = a.toString();:}
	|sig_abre_llave EL:a sig_cierra_llave {:RESULT = a.toString();:}
	|enteros:a {:RESULT = a.toString();:}
	|id:a {:RESULT = a.toString();:}
	|cadena:a {:RESULT = a.toString();:}
	|re_Vacio:a {:RESULT = a.toString();:};

